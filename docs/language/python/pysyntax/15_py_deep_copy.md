---
title: python中浅拷贝与深拷贝
date: 019-05-19 16:51:40
tags: 
  - Python
---

# python中浅拷贝与深拷贝


> 浅拷贝：不可变的不可变，可变的依旧可变
> 深拷贝：都不可变

## 概念：

- 浅拷贝（Shallow copy）:
   - 拷贝后，重新分配了一块内存，创建了一个新的对象，里面的元素是原对象的子对象的引用。
      - 如果原对象中的元素不可变，拷贝后的对象不会受到影响
      - 如果原对象元素可变，拷贝后的对象也会跟着变。
- 深拷贝（Deep copy）:
   - 深拷贝后，重新分配一块内存，创建了一个新的对象，并且将原来对象的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。
      - 新对象与原对象没有任何关联。
```python
l1 = [1, 2, 3]
l2 = list(l1)

l2
[1, 2, 3]

l1 == l2
True

l1 is l2
False

s1 = set([1, 2, 3])
s2 = set(s1)

s2
{1, 2, 3}

s1 == s2
True

s1 is s2
False
```
## 拷贝方式：

- 浅拷贝：
   - 切片操作
   - 工厂函数
   - copy模块中的copy函数
```python
# 方式一：
l1 = [1, 2, 3]
l2 = l1[:]

# 方式二：
l1 = [1, 2, 3]
l2 = list(l1)


# 方式三：
import copy
l1 = [1, 2, 3]
l2 = copy.copy(l1)
```

- 深拷贝：
   - copy模块中的deepcopy函数
```python

import copy
l1 = [[1, 2], (30, 40)]
l2 = copy.deepcopy(l1))]
```
## 实操理解
```python
l1 = [[1, 2], (30, 40)]
l2 = list(l1)
l1.append(100)
l1[0].append(3)

l1
[[1, 2, 3], (30, 40), 100]

l2
[[1, 2, 3], (30, 40)]

l1[1] += (50, 60)
l1
[[1, 2, 3], (30, 40, 50, 60), 100]

l2
[[1, 2, 3], (30, 40)]
```
## 拷贝注意事项：

- 对于非容器类型（数字、字符、其他‘原子’类型），没有拷贝一说，产生的对象都是原对象的引用。
- 如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。
```python

t1 = (1,2,3)
t2 = copy.deepcopy(t1)
id(t1)
140367323207808
t1
id(t1)
140367323207808
t1 is t2
True
t1 == t2
True

```

- 对于深拷贝，如果被拷贝的对象中存在自身的引用，那么程序会陷入无限循环，且会抛错
   - 深拷贝函数中会维护一个字典，记录已经拷贝的对象与其ID，拷贝过程中，如果字典中已经存储了要拷贝的对象，则会从字典中直接返回
```python
import copy
x = [1]
x.append(x)

x
[1, [...]]

y = copy.deepcopy(x)
y
[1, [...]]
>>>>
---------------------------------------------------------------------------
RecursionError                            Traceback (most recent call last)
Input In [48], in <cell line: 1>()
----> 1 x == y

RecursionError: maximum recursion depth exceeded in comparison
```

   - 异常分析：因为x是一个无限嵌套的列表，y深度拷贝x，也是一个无限嵌套的列表，理论上x == y应该返回True,但x ==y 内部会递归遍历列表x和y中的每一个元素，由于是无限嵌套的，而python为了防止栈崩溃，递归的层数是有界的，不会无休止下去，所以抛出上述异常。

