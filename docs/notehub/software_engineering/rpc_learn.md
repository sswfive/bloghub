---
title: RPC学习
date: 2021-10-06 22:45:50
tags: 
  - 软件工程
---


## RPC概述

### PRC的理解

- RPC的全称： Remote Procedure Call 
- 概念：
  - 远程过程调用，是一个计算机通讯协议
  - 该协议运行运行于一台计算机的程序调用用一台计算机的程序

- 广义的理解RPC：
  - 可以将所有通过网络来进行通讯调用的实现统称为RPC
  - 在此理解下，HTTP也可以视为易总RPC的实现
- 狭义的理解RPC:  
  - 主要区别于HTTP的实现方式（http协议：起始行、header、body三部分）
  - 在传输的数据格式上和传输的控制上独立实现。（使用自定义格式的二进制方式）



### RPC的优缺点

> 主流的考量方式都是和http协议进行对比

#### 优点：

- 传输效率高，
- 发起RPC调用的一方，在编写代码是可忽略RPC的具体实现，如同编写本地函数（类）调用一样

#### 缺点：

- 通用性不高
- 调用双方需要专门实现通信库，不同的开发语言，都要有相关实现。



### RPC的适用场景

- RPC面向产品内部服务间的通讯
- HTTP面向用户与产品服务的通讯



### RPC的四个核心组件：

- Client：服务调用方
- Server：服务提供方
- Client Stub：客户端存根，存放服务端的地址消息，再讲客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方
- Server Stub：服务端存根，接受客户端消息，将消息解包，并调用本地方法

---

## RPC的实现流程

### 流程示意图：

![image-20211009234340751](https://gitee.com/roninsswang/upload-picture/raw/master/blogimg/image-20211009234340751.png)

![image-20211011072235299](https://gitee.com/roninsswang/upload-picture/raw/master/blogimg/image-20211011072235299.png)

### 流程图说明：

1. 调用者（caller/客户端/client）以本地调用的方式发起调用
2. Client stub（客户端存根）收到调用后，负责将调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体
3. Client stub将消息体通过网络发送给服务端
4. Server stub（服务端存根）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数
5. Server stub 根据方法名和参数进行本地调用
6. 被调用者（Server）本地调用执行后将结果返回给Server stub
7. Server stub 将返回值打包编码成消息，并通过网络发送给客户端
8. Client stub 收到消息后，进行拆包解码，返回Client
9. Client 得到本次RPC调用的最终结果

>  Note:
>
> - RPC的目标就是在2-8这些步骤封装起来，让使用者对这些细节透明
> - 总上所述，要想实现rpc服务，其核心需要关注通讯双方传输的数据如何表达、描述以及数据通过网络在调用双方如何传递



---

## RPC消息协议

> 一般实现rpc服务需要考虑两个目标：性能高、跨语言

### 设计rpc消息协议需要考虑的问题：

#### 消息边界问题

> 什么是消息边界：在网络传输中，一方可能连续向另一方多次发送消息，收到数据的一方如何界定数据中包含几条消息，这便是消息边界问题。

解决方案：

- 分隔符法

  - 在每条消息的结尾放置一种特殊的分割符（一种常用的分割符是\r\n），表示已到达本条消息的末尾

  - | Message body | \r\n | Message body | \r\n |
    | ------------ | ---- | ------------ | ---- |

- 长度声明法

  - 长度声明法是在消息的起始位置，用一个固定长度的整数值（通常为4字节）声明本消息的长度，接收者先读取出长度声明，再按照声明的长度读取出相应大小的数据即可。

  - | length | Message body | length | Message body |
    | ------ | ------------ | ------ | ------------ |



> Note: http协议同时使用了上述两种方法
>
> ```http
> HTTP/1.0 200 OK\r\n
> Server: Nginx\r\n
> Content-Type: text/html; charset=utf-8\r\n
> Content-Length: 3456\r\n
> \r\n
> # 此处为3456字节的数据
> ```



#### 消息内容的表现形式的问题

>  消息内容的表现方式: 文本、二进制

- 文本
  - 可以将数据转换为具备某种格式的字符串（如 JSON），将字符串作为消息内容发送。
  - （使用json的弊端就是： 数据中有很多无意义的字符，在网络传输中会造成浪费）
- 二进制
  - 二进制方式就是将数据在内存中的一些列原始二进制位或字节直接在网络中传送，而无需转换为字符串再传送。
  - （采用原始二进制传递，可以省去中间转换的环节，而且数据量也会大大减少，效率更高。）



#### 消息内容的压缩问题

- 在消息数据过大的场景中，为了减轻网络带宽的压力，需要考虑对消息数据进行压缩处理
- 但是需要注意的是，压缩处理是一把双刃剑，虽然能减少数据量减轻带宽压力，但是同时额外增加了压缩和解压缩的过程，压缩和解压缩在处理的时候会有时间的消耗，会导致操作系统的负担加重。有时压缩的成本可能比减少数据量带来的收益还高，就得不偿失了。



### 完成RPC调用需要解决的问题：

#### 1、客户端和服务端如何建立网络连接？

- HTTP通信：HTTP协议是基于 TCP 协议的一层封装。一次 HTTP 通信过程就是发起一次 HTTP 调用，而一次 HTTP 调用就会建立一个 TCP 连接，经历一次“三次握手”的过程来建立连接，完成请求后，再经历一次“四次挥手”的过程来断开连接。
- Socket通信：Socket 通信是基于 TCP/IP 协议的封装，建立一次 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ；另一个运行于服务器端，称为 ServerSocket 。
  - Socket 通信的过程分为四个步骤：服务器监听、客户端请求、连接确认、数据传输。
  - 当客户端和服务端建立网络连接后，就可以发起请求了。但网络不一定总是可靠的，经常会遇到网络闪断、连接超时、服务端宕机等各种异常，通常的处理手段有两种:
    - 链路存活检测：客户端需要定时地发送心跳检测消息（一般是通过 ping 请求）给服务端，如果服务端连续 n 次心跳检测或者超过规定的时间都没有回复消息，则认为此时链路已经失效，这个时候客户端就需要重新与服务端建立连接。
    - 断连重试：通常有多种情况会导致连接断开，比如客户端主动关闭、服务端宕机或者网络故障等。这个时候客户端就需要与服务端重新建立连接，但一般不能立刻完成重连，而是要等待固定的间隔后再发起重连，避免服务端的连接回收不及时，而客户端瞬间重连的请求太多而把服务端的连接数占满。

<img src="/Users/roninsswang/Library/Application Support/typora-user-images/image-20211011072756283.png" alt="image-20211011072756283" style="zoom:25%;" />



#### 2、服务端如何处理请求？

- 同步阻塞方式（BIO），客户端每发一次请求，服务端就生成一个线程去处理。当客户端同时发起的请求很多时，服务端需要创建很多的线程去处理每一个请求，如果达到了系统最大的线程数瓶颈，新来的请求就没法处理了
- 同步非阻塞方式 (NIO)，客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过 I/O 多路复用技术进行处理。就是把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销
- 异步非阻塞方式（AIO），客户端只需要发起一个 I/O 操作然后立即返回，等 I/O 操作真正完成以后，客户端会得到 I/O 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 I/O 读写操作，因为真正的 I/O 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待问题



#### 3、如何高效序列化和反序列化？

> 为什么要对数据进行序列化和反序列化呢？要知道网络传输的耗时一方面取决于网络带宽的大小，另一方面取决于数据传输量。要想加快网络传输，要么提高带宽，要么减小数据传输量，而对数据进行编码的主要目的就是减小数据传输量。比如一部高清电影原始大小为 30GB，如果经过特殊编码格式处理，可以减小到 3GB，同样是 100MB/s 的网速，下载时间可以从 300s 减小到 30s。

- 一般数据在网络中进行传输前，都要先在发送方一端对数据进行编码，经过网络传输到达另一端后，再对数据进行解码，这个过程就是序列化和反序列化。

  - 序列化：把对象转换成字节序列的过程
  - 反序列化：把字节序列回复为对象的过程

- 常用的序列化方式分为两类：

  - 文本类如 XML/JSON 等
  - 二进制类如 PB/Thrift 等

- 如何选用序列化方式？

- > 结合实际业务需求

  - 支持数据结构类型的丰富度。数据结构种类支持的越多越好，这样的话对于使用者来说在编程时更加友好，有些序列化框架如 Hessian 2.0 还支持复杂的数据结构比如 Map、List 等。
  - 跨语言支持。序列化方式是否支持跨语言也是一个很重要的因素，否则使用的场景就比较局限，比如 Java 序列化只支持 Java 语言，就不能用于跨语言的服务调用了。
  - 性能。主要看两点，一个是序列化后的压缩比，一个是序列化的速度。以常用的 PB 序列化和 JSON 序列化协议为例来对比分析，PB 序列化的压缩比和速度都要比 JSON 序列化高很多，所以对性能和存储空间要求比较高的系统选用 PB 序列化更合适；而 JSON 序列化虽然性能要差一些，但可读性更好，更适合对外部提供服务。



## RPC性能的影响因素

### 影响因素

- 序列化：指序列化和反序列化的时间，序列化后的数据字节大小也会直接影响RPC框架性能
  - 常见序列化协议有Thrift、Protobuf、Avro。
- 网络协议：RPC框架可选择的协议有HTTP协议、HTTP/2协议、TCP协议，显然HTTP协议需要对传输内容编码，相对于TCP的二进制编码协议，其开销更大
  - 贴士：目前没有采用UDP的RPC框架
- I/O模型：同步阻塞IO（Blocking IO）、同步非阻塞IO(Non-blocking IO)、IO多路复用（IO Multiplexing）、异步IO（Asynchronous IO）

### 总结：

- 消息的封装格式是RPC框架性能的核心影响因素，所以大多的RPC框架都会设计消息封装格式。封装时要考虑：消息体大小、编码解码难度、解决半包粘包难度。比如Dubbo的消息体数据包括：Dubbo版本号、接口名称、接口版本、方法名、参数列表、参数、附加信息等。

---

# RPC常用框架汇总


##    常用RPC框架：

- go rpc ： golang 原生提供的rpc通信框架，只支持go语言, 采用的是Gob来编码
- RMI：基于java远程方法协议和java的原生序列化实现的RPC框架
- Thrift: facebook出品，采用二进制编码协议，传输协议使用TCP/IP, 通过中间语言IDL来定义接口与数据类型，最后由一个编译器生成不同的编译语言的代码
- gRPC: google出品的跨语言、跨平台的远程调用系统
  - gRPC基于HTTP/2协议， HTTP/2协议的特点：连接多路复用、双向流、服务器推送、请求优先级、首部压缩
  - gRPC支持ProtoBuf：ProtoBuf是google开发的数据序列化协议，性能高， 表达能力强
  - 支持多语言，能够给予语言自动生成客户端和服务端功能库

## 国内的RPC框架

- Dubbo: 阿里开放的Java RPC框架，支持功能极多，但从严格意义上来说，其任然是RPC框架
- Motan: 新浪微博的RPC框架，底层支撑java
- RPCX: 基于go的服务治理的RPC框架，客户端支持跨语言
- Tars: 腾讯的RPC框架
- BRPC: 百度的RPC框架
- HSF: 淘宝系内部RPC框架

---

